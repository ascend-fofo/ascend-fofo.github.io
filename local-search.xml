<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>13测试类</title>
    <link href="/2020/05/11/13%E6%B5%8B%E8%AF%95%E7%B1%BB/"/>
    <url>/2020/05/11/13%E6%B5%8B%E8%AF%95%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Rediskey失效通知"><a href="#Rediskey失效通知" class="headerlink" title="Rediskey失效通知"></a>Rediskey失效通知</h2><p>配置</p><pre><code class="java">@Beanpublic RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) {    RedisMessageListenerContainer container = new RedisMessageListenerContainer();    container.setConnectionFactory(connectionFactory);    return container;}</code></pre><pre><code class="java">@Componentpublic class RedisKeyListener extends KeyExpirationEventMessageListener {    public RedisKeyListener(RedisMessageListenerContainer listenerContainer) {        super(listenerContainer);    }    @Override    public void onMessage(Message message, byte[] pattern) {        super.onMessage(message, pattern);    }}</code></pre><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><strong>推荐使用</strong> <a href="https://github.com/xuxueli/xxl-job/" target="_blank" rel="noopener">xxl-job</a></p><pre><code class="java">@Configuration@EnableScheduling@Log4jpublic class ScheduledController {    @Scheduled(fixedRate = 1000)    @Scheduled(cron = &quot;* * * * * ?&quot;)    public void testScheduled() {        log.info(&quot;{--------------------}&quot;);    }}//注意在集群环境下的定时任务重复执行问题</code></pre><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p><strong>为什么要做测试？为什么要写测试类？</strong></p><p><strong>以后出去工作后有一个叫做测试覆盖率的一个考核标准</strong></p><p><strong>使用快捷键生成测试类</strong></p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class UserUtilsTest {    @Autowired    private UserUtils userUtils;    @Test    public void setUser() throws Exception {        System.out.println(&quot;{??????????????????????}&quot;);    }  //前置运行    @After    public void after(){        System.out.println(&quot;{222222222222222222222}&quot;);    }    //后置运行    @Before    public void init() {        System.out.println(&quot;{1111111111111111111}&quot;);    }</code></pre><pre><code class="java">//测试接口@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class ControllerDemoTest {    @Autowired    private MockMvc mockMvc;    @Test    public void getInt() throws Exception {        MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;controllerDemo/getInt&quot;);        requestBuilder.param(&quot;name&quot;,&quot;value&quot;);        mockMvc.perform(requestBuilder).andExpect(MockMvcResultMatchers.status().isOk()).                andExpect(MockMvcResultMatchers.content().string(&quot;success&quot;));    }}</code></pre><h2 id="springboot异步方法-多线程"><a href="#springboot异步方法-多线程" class="headerlink" title="springboot异步方法 多线程"></a>springboot异步方法 多线程</h2><h2 id="多数据源读写分离"><a href="#多数据源读写分离" class="headerlink" title="多数据源读写分离"></a>多数据源读写分离</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12Rediskey失效通知</title>
    <link href="/2020/05/11/12Rediskey%E5%A4%B1%E6%95%88%E9%80%9A%E7%9F%A5/"/>
    <url>/2020/05/11/12Rediskey%E5%A4%B1%E6%95%88%E9%80%9A%E7%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="Rediskey失效通知"><a href="#Rediskey失效通知" class="headerlink" title="Rediskey失效通知"></a>Rediskey失效通知</h2><p>配置</p><pre><code class="java">@Beanpublic RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory) {    RedisMessageListenerContainer container = new RedisMessageListenerContainer();    container.setConnectionFactory(connectionFactory);    return container;}</code></pre><pre><code class="java">@Componentpublic class RedisKeyListener extends KeyExpirationEventMessageListener {    public RedisKeyListener(RedisMessageListenerContainer listenerContainer) {        super(listenerContainer);    }    @Override    public void onMessage(Message message, byte[] pattern) {        super.onMessage(message, pattern);    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>11消息中间件</title>
    <link href="/2020/05/11/11%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2020/05/11/11%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h2 id="为什么要用消息中间件？"><a href="#为什么要用消息中间件？" class="headerlink" title="为什么要用消息中间件？"></a>为什么要用消息中间件？</h2><blockquote><p><strong>实际上提到了为什么，那么是不是说就要说一下消息中间件的优势</strong></p><p><strong>他的优势很简单就是异步处理，流量削峰，但是适用于不关心返回结果的方法</strong></p></blockquote><h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><p>这是消息中间件中的一种还有RabbitMQ ，kafka</p><h2 id="连接ActiveMQ"><a href="#连接ActiveMQ" class="headerlink" title="连接ActiveMQ"></a>连接ActiveMQ</h2><p>##步骤：</p><blockquote><p><strong>① 依赖</strong></p><pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-activemq --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;   &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>②配置</strong></p><pre><code class="properties">#链接地址spring.activemq.broker-url=tcp://127.0.0.1:61616#默认情况下activemq提供的是queue模式，如果要使用topic 则选择truespring.jms.pub-sub-domain=falsespring.activemq.user=adminspring.activemq.password=admin#信任所有的包spring.activemq.packages.trust-all=true</code></pre><p><strong>③使用 2</strong></p><pre><code class="java">//工具类@Componentpublic class ActiveMqUtils {   @Autowired   private JmsMessagingTemplate jmsMessagingTemplate;   public void sendQueueMsg(String name, Object msg) {       Destination destination = new ActiveMQQueue(name);//        Destination destinations = new ActiveMQTopic(name);       jmsMessagingTemplate.convertAndSend(destination, msg);   }}</code></pre><pre><code class="java">//发送与接收点对点消息@Autowiredprivate ActiveMqUtils activeMqUtils;@GetMapping(value = &quot;/sendMsg&quot;)public void sendMsg(@RequestParam String msg) {   activeMqUtils.sendQueueMsg(&quot;test&quot;,&quot;test&quot;);}@JmsListener(destination = &quot;test&quot;)public String getMsg(String msg){   return msg;}</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10Springboot 整合 Dubbo框架</title>
    <link href="/2020/05/11/10Springboot%20%E6%95%B4%E5%90%88%20Dubbo%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/05/11/10Springboot%20%E6%95%B4%E5%90%88%20Dubbo%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="Springboot-整合-Dubbo框架"><a href="#Springboot-整合-Dubbo框架" class="headerlink" title="Springboot 整合 Dubbo框架"></a>Springboot 整合 Dubbo框架</h2><p><strong>项目搭建</strong></p><blockquote><p><strong>生产者：provider</strong></p><p><strong>责任：提供数据</strong></p><p><strong>注册中心 zookeeper</strong></p><p><strong>责任：提供地址让生产者与消费者进行注册</strong></p><p><strong>消费者：consumer</strong></p><p><strong>责任：调用接口消费数据</strong></p></blockquote><h3 id="开始搭建项目"><a href="#开始搭建项目" class="headerlink" title="开始搭建项目"></a>开始搭建项目</h3><p><strong>步骤</strong></p><blockquote><p><strong>①搭建一个空白的项目 springboot或者maven都可以</strong></p><p><strong>②分别搭建provider与consumer项目</strong></p><p><strong>③java -jar 命令启动dubbo-admin.jar</strong></p><blockquote><p><strong>dubbo-admin是阿里开发的一个框架，给访问zookeeper提供了可视化页面</strong></p><p><strong>也提供了一些功能如负载均衡，熔断等等</strong></p></blockquote><p><strong>④确认可以访问dubbo-admin</strong></p><p><strong>⑤分别让provider与consumer连接dubbo-admin</strong></p><p><strong>步骤</strong></p><blockquote><p><strong>provider</strong></p><p><strong>①依赖</strong></p><pre><code class="xml">&lt;!-- dubbo-spring-boot-starter 开始 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- dubbo-spring-boot-starter 结束 --&gt;&lt;!-- zkclient 依赖提供了连接zookeeper的能力--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.101tec&lt;/groupId&gt;  &lt;artifactId&gt;zkclient&lt;/artifactId&gt;  &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- zkclient 依赖提供了连接zookeeper的能力--&gt;</code></pre><p><strong>②配置</strong></p><pre><code class="properties">dubbo.application.name=dubbo-providerserver.port=9003dubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.scan.base-packages=com.kgc.cn.servicedubbo.protocol.port=-1</code></pre></blockquote><p><strong>至此provider配置完成</strong></p><p><strong>为了使后面的consumer与provider项目不产生直接连接所以需要一个中间项目common</strong></p><p><strong>创建中间项目common项目</strong></p><blockquote><p><strong>创建完中间项目后在provider项目中添加common项目的依赖</strong></p><pre><code>&lt;groupId&gt;com.kgc.cn&lt;/groupId&gt;&lt;artifactId&gt;common&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</code></pre><p><strong>最后把service接口放到common项目中</strong></p></blockquote></blockquote><blockquote><p><strong>最后再创建一个consumer项目然后在项目</strong></p><p><strong>步骤</strong></p><blockquote><p><strong>①添加common项目依赖</strong></p><pre><code class="xml">&lt;groupId&gt;com.kgc.cn&lt;/groupId&gt;&lt;artifactId&gt;common&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</code></pre><p><strong>②添加zk与dubbo依赖</strong></p><pre><code class="xml">&lt;!-- dubbo-spring-boot-starter 开始 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt;  &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;0.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- dubbo-spring-boot-starter 结束 --&gt;&lt;!-- zkclient 依赖提供了连接zookeeper的能力--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.101tec&lt;/groupId&gt;  &lt;artifactId&gt;zkclient&lt;/artifactId&gt;  &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;</code></pre></blockquote></blockquote><h3 id="dubbo-admin功能部分"><a href="#dubbo-admin功能部分" class="headerlink" title="dubbo-admin功能部分"></a>dubbo-admin功能部分</h3><p><strong>禁止</strong></p><blockquote><p><strong>禁止消费者访问生产者</strong></p></blockquote><p><strong>屏蔽和容错</strong></p><blockquote><p><strong>不会访问生产者，同时也不会报错</strong></p><p><strong>注意：项目中添加容错请添加fastjson依赖</strong></p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.58&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>ngrok http 8080</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>09统一返回类与ByExample</title>
    <link href="/2020/05/11/09%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%B1%BB%E4%B8%8EByExample/"/>
    <url>/2020/05/11/09%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%B1%BB%E4%B8%8EByExample/</url>
    
    <content type="html"><![CDATA[<h2 id="统一返回类与ByExample与单例模式"><a href="#统一返回类与ByExample与单例模式" class="headerlink" title="统一返回类与ByExample与单例模式"></a>统一返回类与ByExample与单例模式</h2><p><strong>使用example进行增删改查非常方便</strong></p><pre><code class="java">goodsExample.createCriteria().andGIdEqualTo(1l).andGNameEqualTo(&quot;good1&quot;);</code></pre><pre><code class="java">goodsExample.clear(); //清除条件方法</code></pre><pre><code>//order bygoodsExample.setOrderByClause(&quot;g_id DESC&quot;);//去重复goodsExample.setDistinct(true);</code></pre><p>###使用统一返回包装类PageUtils</p><pre><code class="java">@Datapublic class PageUtils&lt;T&gt; {    //当前页    private int currentPage;    //一页多少条    private int pageSize;    //返回对象    private Collection&lt;T&gt; currentList;    //总条数    private long totalCount;    //总页数    private long totalPage = 0l;    //页码    private int pageNo;    public int getPageNo() {        return pageNo * pageSize - pageSize;    }    public void setPageNo(int pageNo) {        this.pageNo = pageNo;    }    public void setTotalPage(int totalPage) {        this.totalPage = totalPage;    }    public long getTotalPage() {        if (totalCount % pageSize == 0) {            totalPage = totalCount / pageSize;        } else {            totalPage = totalCount / pageSize + 1;        }        return totalPage;    }}</code></pre><p><strong>使用example查询分页</strong></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><blockquote><p><strong>① 在对应的example实体类中如GoodsExample中添加两个字段 limt 与 offset 然后getset方法</strong></p><p><strong>② 在对应的sql 如selectByExample 中最后添加</strong></p><pre><code class="xml">&lt;if test=&quot;limit != null&quot;&gt;   &lt;if test=&quot;offset != null&quot;&gt;       limit ${limit},${offset}   &lt;/if&gt;   &lt;if test=&quot;offset == null&quot;&gt;       limit ${limit}   &lt;/if&gt;&lt;/if&gt;</code></pre></blockquote><p><strong>为什么需要统一包装类？</strong></p><p>可以传递一个对象，方便前端接收</p><p>那么这个对象里可以有 T data，String message用来描述状态，状态码int code </p><p><strong>示栗：</strong></p><pre><code class="java">@Datapublic class ReturnResult&lt;T&gt; implements Serializable{    private Integer code;    private String message;    private T data;}</code></pre><p><strong>设计一个返回utils</strong></p><pre><code class="java">public class ReturnResultUtils {    /**     * 不带data的成功     * @return     */    public static ReturnResult returnSuccess() {        ReturnResult returnResult = new ReturnResult();        returnResult.setCode(0);        returnResult.setMessage(&quot;success&quot;);        return returnResult;    }    /**     * 带data的成功     * @param data     * @return     */    public static ReturnResult returnSuccess(Object data) {        ReturnResult returnResult = new ReturnResult();        returnResult.setCode(0);        returnResult.setMessage(&quot;success&quot;);        returnResult.setData(data);        return returnResult;    }    /**     * 自定义code msg返回失败     * @param code     * @param msg     * @return     */    public static ReturnResult returnFail(int code,String msg){        ReturnResult returnResult = new ReturnResult();        returnResult.setCode(code);        returnResult.setMessage(msg);        return returnResult;    }}</code></pre><p><strong>练习：注册</strong></p><p>往数据库保存数据（密码（SHA加密保存），性别（1，2，3），昵称（8），手机号（短信验证，），创建时间（sql函数，Date,bigint(long) getTime() ）…）</p><p>用户积分 ：微信登录 100 -&gt;请输入手机号-&gt;短信验证(证明是否是你手机号)-&gt;该手机号下面是否有用户-&gt;有这个用户-&gt;捆绑（中间表存 id wId pnum ctime 为了解耦合） </p><p>​                   手机登录 100 -&gt;先去中间表看看这个用户有没有用微信号绑定的账号，有的话-&gt;合并账号</p><p>173000000</p><p>123456-&gt;dfdgsgsjajflasddfk@!!LKJ#KLjjjfaew substring (0,16)</p><p>去验证密码时候：123456 -》加密A  从数据库根据账号取出加密密码B  判断a==b</p><p><strong>为什么打log日志</strong></p><p>人为什么要写日志？</p><p>①方便以后查看（如何保持日志，把日志保持到哪里）</p><p>②方便查找错误的地方</p><p><strong>日志在什么地方显示？如何显示？</strong></p><p>项目部署在哪里？服务器上的容器（Tomcat，jbooss）里，</p><p>日志在容器里，那么如何显示？我要先打日志，然后看</p><p>怎么看？这是以后要在linux上学习到的。</p><p>###Logback是springboot默认日志框架</p><p>log从大往小的一个级别</p><blockquote><p><strong>ERROR &gt; WARN &gt; INFO &gt; DEBUG</strong></p></blockquote><p><strong>自定义异常</strong></p><p>为毛要定义异常？</p><p>因为我想自定义异常的code与msg</p><p><strong>使用枚举做单例模式</strong></p><blockquote><p><strong><em>一个类中有且只有一个实例并向整个项目提供这个实例</em></strong></p></blockquote><p><strong>饿汉模式</strong></p><pre><code class="java">public class Singletion {    private static Singletion singletion = new Singletion();    private Singletion() {    }    public static Singletion getInstance() {        return singletion;    }}</code></pre><p><strong>懒汉模式</strong></p><pre><code class="java">/** * 懒汉模式 */public class Singletonb {    //可见性    private volatile static Singletonb singletionb;    //私有化构造方法只有Singletonb类内部才可以调用构造器    private Singletonb() {    }    public static Singletonb getInstance() {        if (null == singletionb) {            //互斥锁            synchronized (Singletonb.class) {                if (null == singletionb) {                    singletionb = new Singletonb();                }            }        }        return singletionb;    }}</code></pre><p><strong>使用枚举创建单例模式</strong></p><pre><code class="java">public enum EnumSingleton {    INSTANCE;    public EnumSingleton getInstance() {        return INSTANCE;    }}</code></pre><p><strong>为什么使用枚举类创建单例模式？</strong></p><p>枚举类实际上是个语法糖，有jvm保证枚举类的唯一性</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08Mysql+Mybatis+Generator</title>
    <link href="/2020/05/11/08Mysql+Mybatis+Generator/"/>
    <url>/2020/05/11/08Mysql+Mybatis+Generator/</url>
    
    <content type="html"><![CDATA[<h3 id="Mysql-Mybatis-Generator"><a href="#Mysql-Mybatis-Generator" class="headerlink" title="Mysql+Mybatis+Generator"></a>Mysql+Mybatis+Generator</h3><p><strong>Mysql</strong></p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><blockquote><p><strong>①依赖</strong></p><pre><code class="xml">&lt;!-- mysql-connector-java 开始 --&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql-connector-java 结束 --&gt;</code></pre><p><strong>②配置</strong></p><pre><code class="xml">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8spring.datasource.password=rootspring.datasource.username=rootspring.datasource.driverClassName=com.mysql.jdbc.Driver</code></pre></blockquote><p><strong>Mybatis</strong></p><blockquote><p><strong>步骤</strong></p><p><strong>①依赖</strong></p><pre><code class="xml">&lt;!-- mybatis-spring-boot-starter开始 --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;   &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mybatis-spring-boot-starter结束 --&gt;</code></pre></blockquote><p><strong>Mybatis-generator</strong></p><blockquote><p><strong>步骤</strong></p><p><strong>①插件依赖</strong></p><pre><code class="xml">&lt;build&gt;   &lt;plugins&gt;       &lt;!--添加mybatisgenerator插件 目的是为了能够生成某张或者某几张表的增删改查基础mybatis文件--&gt;       &lt;plugin&gt;           &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;           &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;           &lt;version&gt;1.3.5&lt;/version&gt;           &lt;!--因为要生成文件，所以这个插件也需要去链接数据库，这里就是插件中需要依赖的标准写法--&gt;           &lt;dependencies&gt;               &lt;dependency&gt;                   &lt;groupId&gt;mysql&lt;/groupId&gt;                   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                   &lt;version&gt;5.1.47&lt;/version&gt;               &lt;/dependency&gt;           &lt;/dependencies&gt;           &lt;!--这里就是说如果重复生成某张表的mybatis文件就会覆盖--&gt;           &lt;configuration&gt;               &lt;overwrite&gt;true&lt;/overwrite&gt;           &lt;/configuration&gt;       &lt;/plugin&gt;       &lt;plugin&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       &lt;/plugin&gt;   &lt;/plugins&gt;   &lt;resources&gt;       &lt;resource&gt;           &lt;directory&gt;src/main/java&lt;/directory&gt;           &lt;includes&gt;               &lt;include&gt;**/*.xml&lt;/include&gt;           &lt;/includes&gt;       &lt;/resource&gt;       &lt;resource&gt;           &lt;directory&gt;src/main/resources&lt;/directory&gt;       &lt;/resource&gt;   &lt;/resources&gt;&lt;/build&gt;</code></pre><p><strong>② generator配置文件</strong></p><p>发qq了，这个文件放在resources包下，记得去修改你的要生成实体类（dto）的位置，mapper java的位置，mapper xml的位置 然后在table标签下 修改你要生成表的名字 最后点击idea右侧maven 点到plugin下的mybatis-generator 双击生成所有配置</p></blockquote><p>课外**</p><p>mysql都是用一次连接一次断开一次后面要用的时候再去连接</p><p>会造成性能效率问题，如何去解决呢？<strong>JNDI</strong></p><p>分库</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07Swagger</title>
    <link href="/2020/05/11/07Swagger/"/>
    <url>/2020/05/11/07Swagger/</url>
    
    <content type="html"><![CDATA[<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><blockquote><p><strong>接口文档是给谁看的？</strong></p><p>给前端开发看的</p><p><strong>为什么要写接口文档？</strong></p><p>就是可以让前后端进行对接</p></blockquote><p><strong>课外</strong></p><pre><code class="java">@GetMapping(value = &quot;/getGoods/{str}&quot;)public Goods getGoods(@PathVariable(name = &quot;str&quot;) String str)@Validated </code></pre><p><strong>步骤</strong></p><blockquote><p>①<strong>依赖</strong></p><pre><code class="xml">&lt;!--swagger 开始--&gt;&lt;dependency&gt;   &lt;groupId&gt;io.springfox&lt;/groupId&gt;   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;   &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--swagger 结束--&gt;&lt;!-- swaggerui开始 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;           &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;           &lt;version&gt;1.9.3&lt;/version&gt;       &lt;/dependency&gt;       &lt;!-- swaggerui结束 这里相当于给了一层类似于bootstrap的ui界面--&gt;</code></pre><p><strong>②配置</strong></p><pre><code class="java">@Configuration@EnableSwagger2@EnableSwaggerBootstrapUIpublic class SwaggerConfiguration {}</code></pre></blockquote><p><strong>swagger-bootstrap-ui的访问地址</strong></p><p>{host}:{port}doc.html</p><p>swagger中常用注解**</p><pre><code class="java">@Api(tags = &quot;实时查询客户各种操作(例如登录，拓客等)的流水日志&quot;) //也可以用来表示版本号@ApiOperation(&quot;获取商品列表&quot;) //描述接口的功能@ApiModel(value = &quot;商品实体类&quot;) //描述实体类的@ApiModelProperty(value=&quot;描述字段&quot; ，required=true) //这里注意这里的required默认是false</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>06使用token进行登录以及自定义注解的使用</title>
    <link href="/2020/05/11/06%E4%BD%BF%E7%94%A8token%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/11/06%E4%BD%BF%E7%94%A8token%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="使用token进行登录以及自定义注解的使用"><a href="#使用token进行登录以及自定义注解的使用" class="headerlink" title="使用token进行登录以及自定义注解的使用"></a>使用token进行登录以及自定义注解的使用</h3><pre><code class="java">//用于判断是否登录注解@Target(ElementType.METHOD)  //代表我这个自定义注解要放在方法上@Retention(RetentionPolicy.RUNTIME) //运行时有效public @interface LoginRequired {}</code></pre><pre><code class="java">//用于获取用户信息注解@Target(ElementType.PARAMETER) //代表我这个自定义注解要放在形参中@Retention(RetentionPolicy.RUNTIME) //运行时有效public @interface CurrentUser {}</code></pre><p><strong>添加LoginReqComplete实现具体逻辑</strong></p><pre><code class="java">public class LoginReqComplete implements HandlerInterceptor {    @Autowired    private RedisUtils redisUtils;//这里表示在进入方法之前运行逻辑    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //如果方法上没有添加@LoginRequired注解就不需要登录可以访问的接口 也就意味着不要进入这个方法中来        if (!(handler instanceof HandlerMethod)) {            return true;        }        HandlerMethod handlerMethod = (HandlerMethod) handler;        Method method = handlerMethod.getMethod();        //判断接口是否需要登录        LoginRequired methodAnnotation = method.getAnnotation(LoginRequired.class);        if (null != methodAnnotation) {            String token = request.getHeader(&quot;token&quot;);            if (!StringUtils.isEmpty(token)) {                String userToken = (String) redisUtils.get(token);                if (StringUtils.isEmpty(userToken)) {                    throw new RuntimeException(&quot;login error&quot;);                } else {                    LoginUser loginUser = JSONObject.parseObject(userToken, LoginUser.class);                    request.setAttribute(&quot;loginUser&quot;, loginUser);                }            }            return true;        }        //这里为什么改为true下次就知道了        return true;    }    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {    }}</code></pre><p><strong>描述currentuser决定内容</strong></p><pre><code class="java">public class CurrentComplete implements HandlerMethodArgumentResolver {    @Override    /**     * 对形参支持的规定     */    public boolean supportsParameter(MethodParameter parameter) {        return parameter.getParameterType().isAssignableFrom(LoginUser.class) &amp;&amp; parameter.hasParameterAnnotation(CurrentUser.class);        //return false;    }    @Override    /**     * 决定内容的方法 谁会来调用我？     */    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {        LoginUser loginUser = (LoginUser) webRequest.getAttribute(&quot;loginUser&quot;, RequestAttributes.SCOPE_REQUEST);        if (!ObjectUtils.isEmpty(loginUser)) {            return loginUser;        }        return null;    }}</code></pre><p>配置webcofig**</p><pre><code class="java">@Configurationpublic class WebConfiguration implements WebMvcConfigurer {  //注入自己写的具体实现类的bean    @Bean    public LoginReqComplete loginReqComplete(){        return new LoginReqComplete();    }    @Override    public void configurePathMatch(PathMatchConfigurer pathMatchConfigurer) {    }    @Override    public void configureContentNegotiation(ContentNegotiationConfigurer contentNegotiationConfigurer) {    }    @Override    public void configureAsyncSupport(AsyncSupportConfigurer asyncSupportConfigurer) {    }    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer defaultServletHandlerConfigurer) {    }    @Override    public void addFormatters(FormatterRegistry formatterRegistry) {    }    @Override    public void addInterceptors(InterceptorRegistry interceptorRegistry) {      //这里添加一个只要以/开头的请求都会进入loginReqComplete()方法中也就是上面的bean那么最终会进入      //我们写的LoginReqComplete类的逻辑中        interceptorRegistry.addInterceptor(loginReqComplete()).addPathPatterns(&quot;/**&quot;);    }    @Override    public void addResourceHandlers(ResourceHandlerRegistry resourceHandlerRegistry) {    }    @Override    public void addCorsMappings(CorsRegistry corsRegistry) {    }    @Override    public void addViewControllers(ViewControllerRegistry viewControllerRegistry) {    }    @Override    public void configureViewResolvers(ViewResolverRegistry viewResolverRegistry) {    }    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; list) {                    list.add(currentComplete());    }    @Override    public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; list) {    }    @Override    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; list) {    }    @Override    public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; list) {    }    @Override    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; list) {    }    @Override    public void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; list) {    }    @Override    public Validator getValidator() {        return null;    }    @Override    public MessageCodesResolver getMessageCodesResolver() {        return null;    }}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>05购物车</title>
    <link href="/2020/05/11/05%E8%B4%AD%E7%89%A9%E8%BD%A6/"/>
    <url>/2020/05/11/05%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><h4 id="无登录状态加入购物车"><a href="#无登录状态加入购物车" class="headerlink" title="无登录状态加入购物车"></a>无登录状态加入购物车</h4><p><strong>课外不需要添加getset方法了,记得在idea中添加lombok插件</strong></p><pre><code class="xml">&lt;!--lombok--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.12&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p><strong>添加fastjson依赖</strong></p><pre><code class="xml">&lt;!-- fastjson 开始 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;&lt;!-- fastjson 结束 --&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>04Redis</title>
    <link href="/2020/05/11/04Redis/"/>
    <url>/2020/05/11/04Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis</a></h2><h4 id="windows下安装redis"><a href="#windows下安装redis" class="headerlink" title="windows下安装redis"></a>windows下安装redis</h4><blockquote><h4 id="1-下载好Redis"><a href="#1-下载好Redis" class="headerlink" title="1.下载好Redis"></a>1.下载好Redis</h4><h4 id="2-cd到Redis所在目录下，使用命令redis-server-redis-windows-conf"><a href="#2-cd到Redis所在目录下，使用命令redis-server-redis-windows-conf" class="headerlink" title="2.cd到Redis所在目录下，使用命令redis-server redis.windows.conf"></a>2.cd到Redis所在目录下，使用命令redis-server redis.windows.conf</h4><h4 id="3-上一个命令窗口不要关闭，打开新的窗口使用命令redis-cli"><a href="#3-上一个命令窗口不要关闭，打开新的窗口使用命令redis-cli" class="headerlink" title="3.上一个命令窗口不要关闭，打开新的窗口使用命令redis-cli"></a>3.上一个命令窗口不要关闭，打开新的窗口使用命令redis-cli</h4><h4 id="4-进行测试，输入set-test-1-回车-显示ok即可"><a href="#4-进行测试，输入set-test-1-回车-显示ok即可" class="headerlink" title="4.进行测试，输入set test 1  回车  显示ok即可"></a>4.进行测试，输入set test 1  回车  显示ok即可</h4></blockquote><h4 id="为什么不需要安装永久服务"><a href="#为什么不需要安装永久服务" class="headerlink" title="为什么不需要安装永久服务"></a>为什么不需要安装永久服务</h4><p>因为工作了以后，你们本机上有没有redis都可以，公司会提供测试环境下的redis服务</p><h4 id="什么叫Redis"><a href="#什么叫Redis" class="headerlink" title="什么叫Redis"></a>什么叫Redis</h4><blockquote><p><strong><em>Redis是保存在内存中的一个数据库，是以简单的key，value格式来保存数据</em></strong></p><p><strong>默认端口号 6379</strong></p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>因为保存在内存中所以存取数据快，redis是单进程单线程的，所以不存在同时操作redis的情况</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>Redis不适合保存大量数据，一般作为缓存使用，HashMap</p></blockquote><h3 id="五个基本数据类型"><a href="#五个基本数据类型" class="headerlink" title="五个基本数据类型"></a>五个基本数据类型</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>命令 ：</p><p>保存 set key value</p><p>获取 get key</p><p>思考：可不可以把对象保存在字符串类型中？</p><p>需要一个媒介，就是先把对象转为json格式的字符串，然后使用set命令保存到redis 当中</p><p>思考：既然能把对象转为json格式的字符串，那么能不能把已经成为json格式的字符串转回为对象呢？</p><p>是可以的 但是需要一个媒介</p><p>####哈希（Hash）</p><p>命令：</p><p>保存 hset key hash的key hash的value</p><p>获取 hget key hash的key</p><p>获取全部 hgetall key</p><p>思考：根据hgetall 命令想一想hash结构适用于什么业务场景？</p><p>1.购物车 redis key（用户唯一id）hashkey（gid@img_url@gname@msg） value(num)</p><p>2.对象</p><p>思考：为什么用@符号进行分割符？</p><p>中英文下状态一样</p><p>数组有没有length方法？ </p><p>没有,但是有length属性</p><p>string有没有length方法？</p><p>有</p><p>####列表(List)</p><blockquote><p>命令：</p><p>保存：</p><pre><code class="java">lpush key  value ... 或者 rpush key value（多个value空格分割）获取：lrange key start  end</code></pre><p>思考：适用场景？</p><p>单一key对应多个value的场景 比方评论业务，可以重复评论而且有序而且方便分页，</p></blockquote><h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><blockquote><p>使用场景不多</p><p>特点：无序且不可重复</p><p>命令：</p><pre><code class="java">保存  sadd key vaue获取 SMEMBERS key </code></pre></blockquote><h4 id="有序集合（Sset）"><a href="#有序集合（Sset）" class="headerlink" title="有序集合（Sset）"></a>有序集合（Sset）</h4><blockquote><p>命令：</p><p>保存：zadd key score value score value …</p><p>获取：zrange key start end</p><p>这里注意不要把score值变得重复</p><p>适用场景：</p><p>某个需要不能重复的，但是可以无序的场景</p></blockquote><h3 id="将Redis集成到Springboot中"><a href="#将Redis集成到Springboot中" class="headerlink" title="将Redis集成到Springboot中"></a>将Redis集成到Springboot中</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><blockquote><h4 id="①依赖"><a href="#①依赖" class="headerlink" title="①依赖"></a>①依赖</h4><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h4 id="②配置-配置类，配置文件"><a href="#②配置-配置类，配置文件" class="headerlink" title="②配置(配置类，配置文件)"></a>②配置(配置类，配置文件)</h4><blockquote><p>配置文件：</p><pre><code class="properties">spring.redis.host=localhostspring.redis.port=6379</code></pre><p>配置类：</p><pre><code class="java">@Configurationpublic class RedisConfig {   @Bean   public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory){       RedisTemplate&lt;String,Object&gt; template = new RedisTemplate&lt;String,Object&gt;();       template.setConnectionFactory(factory);       Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);       ObjectMapper om = new ObjectMapper();       om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);       om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);       jackson2JsonRedisSerializer.setObjectMapper(om);       StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();       //key序列化       template.setKeySerializer(stringRedisSerializer);       //hashkey序列化       template.setHashKeySerializer(stringRedisSerializer);       //value序列化使用jackson       template.setValueSerializer(jackson2JsonRedisSerializer);       //hashvalue序列化使用jackson       template.setHashValueSerializer(jackson2JsonRedisSerializer);       template.afterPropertiesSet();       return template;   }}</code></pre></blockquote><h4 id="③使用"><a href="#③使用" class="headerlink" title="③使用"></a>③使用</h4><pre><code class="java">添加redisutilspublic class RedisUtils {   @Autowired   private RedisTemplate&lt;String, Object&gt; redisTemplate;   /**    * string 类型存入    *    * @param key    * @param value    * @return    */   public boolean set(String key, Object value) {       //todo       try {           redisTemplate.opsForValue().set(key, value);           return true;       } catch (Exception e) {           e.printStackTrace();           return false;       }   }   /**    * string 类型获取    * @param key    * @return    */   public Object get(String key) {       return key == null ? null : redisTemplate.opsForValue().get(key);   } /**    * 删除可以多个删除    * @param key    */   public void del(String... key) {       if (key != null &amp;&amp; key.length &gt; 0) {           if (key.length == 1) {               redisTemplate.delete(key[0]);           } else {               redisTemplate.delete(CollectionUtils.arrayToList(key));           }       }   } /**    * 指定key失效时间    * @param key    * @param time    * @return    */   public boolean expire(String key, long time) {       try {           if (time &gt; 0) {               redisTemplate.expire(key, time, TimeUnit.SECONDS);           }           return true;       } catch (Exception e) {           e.printStackTrace();           return false;       }   }}</code></pre></blockquote><h4 id="思考为什么要序列化？"><a href="#思考为什么要序列化？" class="headerlink" title="思考为什么要序列化？"></a>思考为什么要序列化？</h4><p>在java中，一切都可以叫对象，而我们想要将对象进行信息传输（报错）或者存储（否则乱码）的时候就需要进行序列化</p><h4 id="理解了对象需要序列化，那么为什么我们要去重写之前springboot自带的redisTemplate？"><a href="#理解了对象需要序列化，那么为什么我们要去重写之前springboot自带的redisTemplate？" class="headerlink" title="理解了对象需要序列化，那么为什么我们要去重写之前springboot自带的redisTemplate？"></a>理解了对象需要序列化，那么为什么我们要去重写之前springboot自带的redisTemplate？</h4><p>找到org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration这个类</p><p>这是在springboot启动的时候就被加载的配置类，现在先看redisTemplate这个方法，现在发现这个方法泛型中皆为obj</p><p>那么每次都需要进行转值比较麻烦。</p><p>那么再看下面的stringRedisTemplate方法提供的泛型是string,string不够灵活而且缺少序列化k与v</p><p>其中有两个标签</p><pre><code class="java">@Bean  //相当于spring中&lt;bean&gt;标签的作用@ConditionalOnMissingBean //山中无老虎猴子称大王 如果有其他的同名的bean则会被覆盖</code></pre><h4 id="在spring中提供了若干的序列化器"><a href="#在spring中提供了若干的序列化器" class="headerlink" title="在spring中提供了若干的序列化器"></a>在spring中提供了若干的序列化器</h4><p>Jackson2JsonRedisSerializer 就是一个序列化器</p><h4 id="课外"><a href="#课外" class="headerlink" title="课外"></a>课外</h4><p><strong><em>String… key</em></strong> 参数里写这个可以有多个也可以传入单个字符串，当单个字符串进入方法后会自动转换为数组，所以取值要按数组的方式来进行取值如：array[0]</p><p><strong>Collection</strong> 是所有集合的父类</p><p><strong>Collections</strong> 提供了集合的工具类，提供了对集合操作的一些方法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>03微服务架构及项目架构设计</title>
    <link href="/2020/05/11/03%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/05/11/03%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8A%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="微服务架构及项目架构设计"><a href="#微服务架构及项目架构设计" class="headerlink" title="微服务架构及项目架构设计"></a>微服务架构及项目架构设计</h2><h3 id="在IT行业中有很多的职位"><a href="#在IT行业中有很多的职位" class="headerlink" title="在IT行业中有很多的职位"></a>在IT行业中有很多的职位</h3><blockquote><p><strong><em>产品</em></strong></p><p>要设计产品文档，并且要和各个开发过需求</p><p><strong><em>架构</em></strong></p><p>选择技术方向，语言，web应用，框架，要用到什么技术，会出现哪些问题？比方说性能问题并且要解决问题</p><p>他也需要些代码，但是往往是处理一些难度比较大的代码</p><p><strong><em>项目经理</em></strong></p><p>更多的是偏向于管理而会因此弱化技术，但是会非常有利于你的终身发展</p><p><strong><em>普通开发</em></strong></p><blockquote><p><strong><em>前端开发</em></strong></p><p><strong><em>后端开发</em></strong></p><p>（这里职位高低不分顺序）</p></blockquote><p><strong><em>测试</em></strong></p><p><strong><em>运维</em></strong></p></blockquote><h3 id="集群服务器"><a href="#集群服务器" class="headerlink" title="集群服务器"></a>集群服务器</h3><blockquote><p>若干个服务器运行同一个项目</p><p>解决了<strong><em>高可用</em></strong></p></blockquote><p>###分布式微服务框架</p><blockquote><p>将之前的一个项目，按照业务拆分为一个个小项目，并且这些小项目之间有相互的调用</p><p>解决了<strong><em>高并发</em></strong></p></blockquote><p>我需要有<strong><em>消费者</em></strong>和<strong><em>生产者</em></strong>，然后我的消费者与生产者同时要知道这个<strong><em>注册中心</em></strong>在哪里，然后进行注册</p><p>那么生产者需要在<strong><em>注册中心</em></strong>上暴露自己的接口，消费者需要在注册中心上能够发现这个接口从而进行消费</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>02springboot实用技巧</title>
    <link href="/2020/05/11/02springboot%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/05/11/02springboot%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="springboot实用技巧"><a href="#springboot实用技巧" class="headerlink" title="springboot实用技巧"></a>springboot实用技巧</h2><h4 id="从配置文件中获取配置"><a href="#从配置文件中获取配置" class="headerlink" title="从配置文件中获取配置"></a>从配置文件中获取配置</h4><p>疑问为什么要从配置文件中获取配置？</p><p>1 可以当做常量来使用</p><p>如何从配置文件中获取配置？</p><blockquote><p>自己查idea格式化快捷键</p></blockquote><p>坑：</p><p>1中文乱码</p><p>2不要将属性写为user.name 这样会获取你电脑的用户名</p><h4 id="获取方式一"><a href="#获取方式一" class="headerlink" title="获取方式一"></a>获取方式一</h4><pre><code class="java">value(&quot;${}&quot;)//细节 注意配置中的字符串会默认加上&quot;&quot;符号 所以不需要加</code></pre><p><strong><em>课外 # 与$符号的区别？</em></strong></p><p>做完练习后我们想一下 这个有什么缺点？</p><p>有点麻烦，如果要获取若干配置的话，那么就需要一个个取值</p><h4 id="获取方式二"><a href="#获取方式二" class="headerlink" title="获取方式二"></a>获取方式二</h4><pre><code class="java">@ConfigurationProperties(prefix = &quot;这里写头&quot;)@componet //一定要记得加</code></pre><p>这里返回空json，推荐安装谷歌浏览器json插件（json-handle）</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>可以大范围多字段一次性获取多个属性</p><h3 id="使用配置文件创建多环境以及环境的选择"><a href="#使用配置文件创建多环境以及环境的选择" class="headerlink" title="使用配置文件创建多环境以及环境的选择"></a>使用配置文件创建多环境以及环境的选择</h3><p>dev 表示开发环境</p><p>sit 表示测试环境</p><p>prd 表示正式线上环境</p><h4 id="痛点，不同的环境下的数据库链接不同，用户名，密码等等配置都有可能不同"><a href="#痛点，不同的环境下的数据库链接不同，用户名，密码等等配置都有可能不同" class="headerlink" title="痛点，不同的环境下的数据库链接不同，用户名，密码等等配置都有可能不同"></a>痛点，不同的环境下的数据库链接不同，用户名，密码等等配置都有可能不同</h4><h4 id="如果换个环境就去该配置文件的话太麻烦了"><a href="#如果换个环境就去该配置文件的话太麻烦了" class="headerlink" title="如果换个环境就去该配置文件的话太麻烦了"></a>如果换个环境就去该配置文件的话太麻烦了</h4><p>凡是没有使用多环境的公司，都是垃圾</p><h3 id="所以产生了多环境的配置文件与选择配置文件"><a href="#所以产生了多环境的配置文件与选择配置文件" class="headerlink" title="所以产生了多环境的配置文件与选择配置文件"></a>所以产生了多环境的配置文件与选择配置文件</h3><p>步骤：</p><blockquote><p>①创建多环境配置规范</p><p>例如：application-dev.properties</p><p>要在原先的配置环境下新加一个配置文件，然后在application后加-符号加上你需要的环境名即可</p><p>②选择某个环境</p><pre><code class="java">spring.profiles.active=dev  //后面这里写的是环境名（也就是-后面的字符）</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01SpringBoot</title>
    <link href="/2020/05/11/01SpringBoot/"/>
    <url>/2020/05/11/01SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><blockquote><p><strong><em>当我跑步的时候我在说什么</em></strong></p><p><strong><em>当我在说Springboot的时候我在说什么？</em></strong></p></blockquote><p>Spring Mybatis SpringMVC(垂直框架)</p><p>###重要思想：</p><blockquote><p><strong><em>控制反转</em></strong></p><p>1.这个名词是不是翻译过来的？</p><p>2.什么叫正转？</p><p>正：</p><p>new -&gt;实例化-&gt;name.function()</p><p>3.那么什么叫反转？</p><p>反：</p><p>我控制不了或者不需要控制实例</p><p><strong><em>依赖注入</em></strong></p></blockquote><h3 id="之前框架的问题"><a href="#之前框架的问题" class="headerlink" title="之前框架的问题"></a>之前框架的问题</h3><blockquote><p>1.烦</p><p>2.tomcat</p><p>3.搭建框架步骤繁琐</p><p>4.前端文件还写在后端框架中</p></blockquote><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p><strong><em>使用Springboot框架</em></strong>（微服务框架）</p><p>步骤：</p><blockquote><p>有两种方式：</p><p>1在网址：<a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 下创建，根据你需要的进行选择然后创建</p><p>2推荐方式使用idea：</p><p><strong><em>注意修改版本号</em></strong></p><pre><code class="java">&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</code></pre><p>设置idea默认maven配置</p><p>添加maven3.39</p><p>打开conf文件夹中的setting文件修改其中</p><pre><code class="xml">&lt;localRepository&gt;这里请复制你需要保存依赖jar的本机文件夹地址&lt;/localRepository&gt;</code></pre><p>修改test问题，因为现在的版本已经到junit5了所以需要添加新依赖进来进入com.example.demo.DemoApplicationTests文件下使用快捷键添加依赖，等待载入依赖</p></blockquote><h3 id="SpringBoot优势"><a href="#SpringBoot优势" class="headerlink" title="SpringBoot优势"></a>SpringBoot优势</h3><blockquote><p>1.0配置</p><p>2.自带容器（tomcat）</p><blockquote><p>默认端口号：8080</p></blockquote></blockquote><pre><code>pom.xml详解我发现springboot的pom中许多依赖都没有版本号然后我👇这个依赖父依赖的父依赖中发现了版本号spring-boot-starter-parent称之为：版本仲裁器我发现有很多依赖上有starter字样当我点击进去的时候我发现了很多的依赖一开始从spring-boot-starter-web点击进去的我发现这个依赖里面有很多的依赖都是和web有关系，比如说里面有tomcat容器，有springmvc...所以starter定义为：场景启动器，集成了该场景下所需要用到的所有依赖最下面的spring-boot-maven-plugin负责：打包成可执行的jar点开mavn 打包为jar包 到对应的目录下 cd /xxx/xxx  然后输入 java -jar xxxx.jar 命令启动</code></pre><h3 id="详解DemoApplication-项目名-Application"><a href="#详解DemoApplication-项目名-Application" class="headerlink" title="详解DemoApplication(项目名+Application)"></a>详解DemoApplication(项目名+Application)</h3><pre><code class="java">@SpringBootApplication只要是被这个注解修饰的类，就表明这是一个springboot项目的主配置类@SpringBootConfiguration 里面有 @Component 可以注入到spring容器中  定义：表明这是一个配置类（springboot专用）@EnableAutoConfiguration  里面有  @AutoConfigurationPackage  @Import（EnableAutoConfigurationImportSelector） 以全类名的方式导入所有组件  这是spring底层注解，注入了EnableAutoConfigurationImportSelector（自动配置注入选择器） 这个由继承了            AutoConfigurationImportSelector这里面有selectImports方法选择谁来注入看这个方法里的  List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);  然后看getCandidateConfigurations这里面是怎么处理的，这里面调用    List configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());所以我们看下loadFactoryNames这方法里面发现是从 META-INF/spring.factories 下面找的  里面还有  @AutoConfigurationPackage 点进去看  发现@Import({Registrar.class})  点进Registrar类中看  选择new AutoConfigurationPackages.PackageImport(metadata)).getPackageName() 右击计算是    com.example.demo这个结果 可以得知这里把被@SpringBootApplication所修饰的类所在的包以及其子包全部注入到spring中@ComponentScan  扫描你所想注入的包</code></pre><pre><code>@SpringBootApplication被其修饰的类叫springboot的核心配置类，这里面有三个核心注解</code></pre><table><thead><tr><th>@SpringBootConfiguration</th><th>@EnableAutoConfiguration</th><th>@ComponentScan</th></tr></thead><tbody><tr><td><strong><em>核心注解是@Configuration（可以声明一个普通类为配置类）这里面又有@Component，被这个类注解所修饰的类表示springboot专用配置类</em></strong></td><td><strong><em>这里有两个注解分别为，@AutoConfigurationPackage 这个注解会把被其修饰的类所在的包以及其子包注入到spring容器中@Import({EnableAutoConfigurationImportSelector.class})这个注解会到spring-boot-autoconfigure/1.5.9.RELEASE/spring-boot-autoconfigure-1.5.9.RELEASE.jar!/META-INF/spring.factories下以全类名的方式导入所有配置</em></strong></td><td><strong><em>扫描并注入你所想注入的包</em></strong></td></tr></tbody></table><h3 id="为什么要讲这么深"><a href="#为什么要讲这么深" class="headerlink" title="为什么要讲这么深"></a>为什么要讲这么深</h3><blockquote><p><strong><em>1.让大家适应我的教学方法</em></strong></p><p><strong><em>2.核心竞争力</em></strong></p><p>体现在，你知道这是干什么的，你也能知道他为什么能这么干</p></blockquote><h3 id="明天默写上述所有"><a href="#明天默写上述所有" class="headerlink" title="明天默写上述所有"></a>明天默写上述所有</h3><blockquote><p>1.不能抄</p><p>2.怎么默写</p><blockquote><p>1 springboot有哪些优点</p><p>1 ：涉及到风口浪尖啊是垃圾分类家电节</p></blockquote><p>3.所有我要求默写的东西 后面都有很大概率会被面试到</p></blockquote><p>###application.properties</p><blockquote><p><strong><em>springboot配置文件</em></strong></p><p>有两种格式：</p><p>application.properties与application.yml两种，当两种都存在的时候以application.properties为主</p></blockquote><h4 id="课外"><a href="#课外" class="headerlink" title="课外"></a>课外</h4><pre><code>Assert.notEmpty //断言</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>糖糖小可爱</title>
    <link href="/2020/01/13/%E7%B3%96%E7%B3%96%E5%B0%8F%E5%8F%AF%E7%88%B1/"/>
    <url>/2020/01/13/%E7%B3%96%E7%B3%96%E5%B0%8F%E5%8F%AF%E7%88%B1/</url>
    
    <content type="html"><![CDATA[<p>###DW  等我!</p><iframe src="//player.bilibili.com/player.html?aid=76259905&cid=130444896&page=1" width="100%" height="436" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>嘻嘻嘻</p>]]></content>
    
    
    
    <tags>
      
      <tag>love</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fairy</title>
    <link href="/2020/01/13/fairy/"/>
    <url>/2020/01/13/fairy/</url>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1421271649&auto=1&height=66"></iframe>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/01/13/hello-world/"/>
    <url>/2020/01/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=36095122&auto=1&height=66"></iframe><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
